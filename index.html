<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Tati Arcade ‚Äî Pocket Quest</title>
  <style>
    :root{
      --bg1:#12062a; --bg2:#2c0750;
      --glass1:rgba(255,255,255,.14); --glass2:rgba(255,255,255,.08);
      --bd:rgba(255,255,255,.18);
      --tx:#fff; --mt:rgba(255,255,255,.78);
      --p:#b86bff; --p2:#ff5cc8; --g:#52ffa8; --y:#ffd36a; --r:#ff5a78;
      --shadow:0 18px 60px rgba(0,0,0,.45);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; color:var(--tx);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:
        radial-gradient(1000px 600px at 20% 10%, rgba(184,107,255,.18), transparent 60%),
        radial-gradient(900px 700px at 80% 20%, rgba(255,92,200,.14), transparent 55%),
        radial-gradient(900px 700px at 40% 90%, rgba(82,255,168,.10), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow:hidden;
    }

    canvas{ width:100vw; height:100vh; display:block; image-rendering: pixelated; }

    /* HUD (top, minimal like emulator overlay) */
    .hud{
      position:fixed; left:10px; right:10px; top:10px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      z-index:10; pointer-events:none;
    }
    .chip{
      pointer-events:auto;
      padding:8px 10px;
      border-radius:14px;
      background:linear-gradient(180deg, rgba(255,255,255,.16), rgba(255,255,255,.10));
      border:1px solid rgba(255,255,255,.18);
      box-shadow:0 16px 50px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      font-size:12px; color:rgba(255,255,255,.92);
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.14);
      white-space:nowrap;
      font-weight:900;
    }
    .pill.ok{border-color:rgba(82,255,168,.28); background:rgba(82,255,168,.10)}
    .pill.warn{border-color:rgba(255,211,106,.28); background:rgba(255,211,106,.10)}
    .btn{
      pointer-events:auto;
      border:none; border-radius:14px;
      padding:10px 12px; font-weight:900; cursor:pointer;
      background:linear-gradient(180deg, rgba(184,107,255,.98), rgba(255,92,200,.85));
      color:#190424;
    }
    .btn.ghost{
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.18);
      color:#fff;
    }

    /* Touch controls like emulator overlay */
    .touch{
      position:fixed; inset:0;
      z-index:20;
      pointer-events:none;
    }
    .dpad{
      position:absolute; left:16px; bottom:20px;
      width:170px; height:170px;
      border-radius:22px;
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(10px);
      box-shadow:0 18px 60px rgba(0,0,0,.35);
      pointer-events:auto;
      touch-action:none;
    }
    .dpad .cross{
      position:absolute; inset:22px;
      border-radius:16px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.18);
    }
    .dpad .nub{
      position:absolute; left:50%; top:50%;
      width:66px; height:66px;
      transform:translate(-50%,-50%);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(184,107,255,.95), rgba(255,92,200,.75));
      border:1px solid rgba(255,255,255,.20);
      box-shadow:0 10px 28px rgba(0,0,0,.35);
    }

    .ab{
      position:absolute; right:16px; bottom:36px;
      display:flex; gap:12px; align-items:flex-end;
      pointer-events:auto;
    }
    .ab button{
      border:none; cursor:pointer;
      border-radius:999px;
      width:84px; height:84px;
      font-weight:1000; font-size:16px;
      box-shadow:0 18px 50px rgba(0,0,0,.35);
      touch-action:none;
    }
    .ab .a{ background:linear-gradient(180deg, rgba(82,255,168,.95), rgba(82,255,168,.70)); color:#062014; }
    .ab .b{ background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.18); color:#fff; width:70px; height:70px; margin-bottom:8px; }

    .menuRow{
      position:absolute; left:50%; bottom:18px;
      transform:translateX(-50%);
      display:flex; gap:10px;
      pointer-events:auto;
    }
    .menuRow button{
      width:84px; height:38px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.16);
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }

    @media (min-width: 900px){
      .touch{display:none}
    }

    /* Dialog box like Pok√©mon */
    .dialog{
      position:fixed; left:14px; right:14px; bottom:14px;
      z-index:30;
      border-radius:18px;
      border:2px solid rgba(255,255,255,.30);
      background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.25));
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      padding:14px;
      display:none;
    }
    .dialog .name{font-weight:1000; margin-bottom:6px}
    .dialog .text{color:rgba(255,255,255,.92); line-height:1.4}
    .dialog .hint{margin-top:10px; color:rgba(255,255,255,.68); font-size:12px}

    /* Prompt input modal (for codes) */
    .prompt{
      position:fixed; inset:0;
      z-index:50;
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
    }
    .promptCard{
      width:min(520px,100%);
      border-radius:20px;
      border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(180deg, rgba(255,255,255,.16), rgba(255,255,255,.10));
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      padding:16px;
    }
    .promptCard h2{margin:0; font-size:18px}
    .promptCard p{margin:10px 0 0; color:rgba(255,255,255,.78); line-height:1.45}
    .promptRow{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap}
    .promptCard input{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.22);
      color:#fff;
      font-weight:900;
      letter-spacing:.6px;
      outline:none;
      text-transform: uppercase;
    }
    .msg{ margin-top:10px; font-weight:900; color:rgba(255,255,255,.92); }
    .msg.ok{ color: #dcffe9; }
    .msg.bad{ color: #ffd7df; }

    /* Confetti canvas */
    #confetti{position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:60}

    /* ===== WIN SCREEN like your sample ===== */
    .pixel{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      letter-spacing: .5px;
      text-transform: uppercase;
    }
    .winOverlay{
      position:fixed; inset:0;
      display:none;
      z-index:80;
      background: rgba(0,0,0,.60);
      backdrop-filter: blur(6px);
      padding: 18px;
      align-items:center;
      justify-content:center;
    }
    .winCard{
      width:min(520px, 100%);
      border: 4px solid rgba(255,255,255,.85);
      border-radius: 16px;
      overflow:hidden;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      background: #000;
    }
    .winSky{
      position:relative;
      height: 320px;
      background: linear-gradient(#79c8ff, #79c8ff);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .cloud{
      position:absolute;
      width: 92px; height: 36px;
      background: rgba(255,255,255,.92);
      border-radius: 8px;
      opacity:.85;
    }
    .cloud:before, .cloud:after{
      content:"";
      position:absolute;
      background: rgba(255,255,255,.92);
      border-radius: 10px;
    }
    .cloud:before{ width:46px; height:26px; left:-18px; top:10px; }
    .cloud:after{ width:52px; height:28px; right:-16px; top:6px; }
    .c1{ top:34px; left:18px; transform:scale(1.05); }
    .c2{ top:64px; right:22px; transform:scale(.95); }
    .c3{ bottom:88px; left:44px; transform:scale(.9); }

    .winText{
      position:absolute;
      top: 124px;
      left:0; right:0;
      text-align:center;
      font-weight: 1000;
      color: #ffd36a;
      text-shadow: 0 3px 0 rgba(0,0,0,.55);
      font-size: 28px;
    }
    .trophyBtn{
      width: 110px;
      height: 110px;
      border: 4px solid rgba(0,0,0,.35);
      border-radius: 14px;
      background: linear-gradient(180deg, #ffd36a, #ffb84b);
      box-shadow: 0 10px 0 rgba(0,0,0,.25), 0 18px 40px rgba(0,0,0,.25);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      position:absolute;
      top: 34px;
      left:50%;
      transform: translateX(-50%);
      transition: transform .08s ease;
    }
    .trophyBtn:active{ transform: translateX(-50%) scale(.98); }
    .trophyIcon{
      font-size: 56px;
      filter: drop-shadow(0 3px 0 rgba(0,0,0,.25));
    }
    .winGround{
      padding: 14px;
      background: linear-gradient(180deg, rgba(184,107,255,.18), rgba(255,92,200,.10));
      border-top: 4px solid rgba(255,255,255,.35);
    }
    .winHint{
      color: rgba(255,255,255,.90);
      font-weight: 900;
      text-align:center;
      margin: 0;
      font-size: 13px;
    }
    .winModal{
      margin-top: 12px;
      display:none;
      padding: 14px;
      border: 2px dashed rgba(255,255,255,.55);
      border-radius: 14px;
      background: rgba(0,0,0,.35);
    }
    .winQ{
      margin:0;
      color:#fff;
      font-weight:1000;
      font-size: 16px;
      text-align:center;
      text-transform:none;
      letter-spacing:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    }
    .winSub{
      margin:10px 0 0;
      text-align:center;
      color: rgba(255,255,255,.75);
      font-size: 12px;
      line-height:1.4;
      text-transform:none;
      letter-spacing:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    }
    .winBtns{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .winYes{
      border:none;
      border-radius: 14px;
      padding: 10px 14px;
      font-weight:1000;
      cursor:pointer;
      background: linear-gradient(180deg, rgba(184,107,255,.98), rgba(255,92,200,.85));
      color: #190424;
    }
    .winYes:active{ transform: scale(.98); }
    .winClose{
      border:1px solid rgba(255,255,255,.25);
      border-radius: 14px;
      padding: 10px 14px;
      font-weight:900;
      cursor:pointer;
      background: rgba(255,255,255,.10);
      color: #fff;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="chip">
      <span class="pill">Pocket Quest</span>
      <span class="pill warn" id="progress">Puertas: 0/3</span>
      <span class="pill" id="inv">Keys: ‚Äî</span>
    </div>
    <div class="chip">
      <button class="btn ghost" id="sound">Sound: OFF</button>
      <button class="btn ghost" id="pause">Pause</button>
      <button class="btn" id="restart">Restart</button>
    </div>
  </div>

  <canvas id="c"></canvas>
  <canvas id="confetti"></canvas>

  <div class="touch" aria-hidden="true">
    <div class="dpad" id="dpad">
      <div class="cross"></div>
      <div class="nub" id="nub"></div>
    </div>

    <div class="ab">
      <button class="b" id="bBtn">B</button>
      <button class="a" id="aBtn">A</button>
    </div>

    <div class="menuRow">
      <button id="selBtn">SELECT</button>
      <button id="staBtn">START</button>
    </div>
  </div>

  <div class="dialog" id="dialog">
    <div class="name" id="dName">NPC</div>
    <div class="text" id="dText">Texto‚Ä¶</div>
    <div class="hint" id="dHint">Pulsa A pa‚Äô continuar</div>
  </div>

  <!-- Code prompt modal -->
  <div class="prompt" id="prompt">
    <div class="promptCard">
      <h2 id="pTitle">Checkpoint</h2>
      <p id="pBody">Escribe la clave del papel.</p>
      <div class="promptRow">
        <input id="pInput" autocomplete="off" autocapitalize="characters" placeholder="ESCRIBE AQU√ç‚Ä¶" />
      </div>
      <div class="promptRow">
        <button class="btn" id="pOk">Validar</button>
        <button class="btn ghost" id="pCancel">Cancelar</button>
      </div>
      <div class="msg" id="pMsg" style="display:none;"></div>
    </div>
  </div>

  <!-- YOU WIN overlay -->
  <div class="winOverlay" id="winOverlay">
    <div class="winCard">
      <div class="winSky">
        <div class="cloud c1"></div>
        <div class="cloud c2"></div>
        <div class="cloud c3"></div>
        <button class="trophyBtn" id="trophyBtn" aria-label="Trophy">
          <div class="trophyIcon">üèÜ</div>
        </button>
        <div class="winText pixel">YOU WIN!</div>
      </div>
      <div class="winGround">
        <p class="winHint pixel">TAP THE TROPHY</p>
        <div class="winModal" id="winModal">
          <p class="winQ">Tati‚Ä¶ ¬øquieres ser mi novia?</p>
          <p class="winSub">‚ÄúAcepto tus bugs y celebro tus versiones.‚Äù</p>
          <div class="winBtns">
            <button class="winYes" id="winYes1">S√≠</button>
            <button class="winYes" id="winYes2">S√≠</button>
            <button class="winClose" id="winClose">Cerrar</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const conf = document.getElementById('confetti');
  const cctx = conf.getContext('2d');

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    conf.width = Math.floor(window.innerWidth * dpr);
    conf.height = Math.floor(window.innerHeight * dpr);
    cctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== UI refs =====
  const ui = {
    progress: document.getElementById('progress'),
    inv: document.getElementById('inv'),
    sound: document.getElementById('sound'),
    pause: document.getElementById('pause'),
    restart: document.getElementById('restart'),
  };

  const dialog = document.getElementById('dialog');
  const dName = document.getElementById('dName');
  const dText = document.getElementById('dText');
  const dHint = document.getElementById('dHint');

  const prompt = document.getElementById('prompt');
  const pTitle = document.getElementById('pTitle');
  const pBody = document.getElementById('pBody');
  const pInput = document.getElementById('pInput');
  const pOk = document.getElementById('pOk');
  const pCancel = document.getElementById('pCancel');
  const pMsg = document.getElementById('pMsg');

  const winOverlay = document.getElementById('winOverlay');
  const trophyBtn = document.getElementById('trophyBtn');
  const winModal = document.getElementById('winModal');
  const winYes1 = document.getElementById('winYes1');
  const winYes2 = document.getElementById('winYes2');
  const winClose = document.getElementById('winClose');

  // ===== Audio =====
  let soundOn = false;
  let audioCtx = null;
  function beep(freq=440, dur=0.06, type='square', vol=0.05){
    if(!soundOn) return;
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=>o.stop(), dur*1000);
  }
  ui.sound.addEventListener('click', ()=>{
    soundOn = !soundOn;
    ui.sound.textContent = `Sound: ${soundOn ? 'ON' : 'OFF'}`;
    beep(740,0.08);
  });

  // ===== Controls =====
  const keys = {up:false,down:false,left:false,right:false,a:false,b:false};
  let paused = false;

  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='arrowup'||k==='w') keys.up=true;
    if(k==='arrowdown'||k==='s') keys.down=true;
    if(k==='arrowleft'||k==='a') keys.left=true;
    if(k==='arrowright'||k==='d') keys.right=true;
    if(k===' ') { keys.a=true; e.preventDefault(); }
    if(k==='escape') keys.b=true;
    if(k==='p') paused = !paused;
  });
  window.addEventListener('keyup', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='arrowup'||k==='w') keys.up=false;
    if(k==='arrowdown'||k==='s') keys.down=false;
    if(k==='arrowleft'||k==='a') keys.left=false;
    if(k==='arrowright'||k==='d') keys.right=false;
    if(k===' ') keys.a=false;
    if(k==='escape') keys.b=false;
  });

  // Touch D-pad (emulator-ish)
  const dpad = document.getElementById('dpad');
  const nub = document.getElementById('nub');
  const aBtn = document.getElementById('aBtn');
  const bBtn = document.getElementById('bBtn');
  const selBtn = document.getElementById('selBtn');
  const staBtn = document.getElementById('staBtn');

  let dpadActive=false, dpadId=null;
  let dvec={x:0,y:0};
  const dRadius = 54;

  dpad.addEventListener('pointerdown', (e)=>{
    dpadActive=true; dpadId=e.pointerId; dpad.setPointerCapture(dpadId);
    moveDpad(e);
  });
  dpad.addEventListener('pointermove', (e)=>{ if(dpadActive && e.pointerId===dpadId) moveDpad(e); });
  dpad.addEventListener('pointerup', (e)=>{ if(e.pointerId===dpadId) resetDpad(); });
  dpad.addEventListener('pointercancel', ()=>resetDpad());

  function moveDpad(e){
    const r = dpad.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top + r.height/2;
    const dx = e.clientX - cx;
    const dy = e.clientY - cy;
    const len = Math.hypot(dx,dy) || 1;
    const k = Math.min(1, len/dRadius);
    dvec.x = (dx/len)*k;
    dvec.y = (dy/len)*k;
    nub.style.transform = `translate(calc(-50% + ${dvec.x*dRadius}px), calc(-50% + ${dvec.y*dRadius}px))`;
  }
  function resetDpad(){
    dpadActive=false; dpadId=null; dvec={x:0,y:0};
    nub.style.transform = `translate(-50%,-50%)`;
  }

  aBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); keys.a=true; });
  aBtn.addEventListener('pointerup', (e)=>{ e.preventDefault(); keys.a=false; });
  aBtn.addEventListener('pointercancel', ()=>{ keys.a=false; });

  bBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); keys.b=true; });
  bBtn.addEventListener('pointerup', (e)=>{ e.preventDefault(); keys.b=false; });
  bBtn.addEventListener('pointercancel', ()=>{ keys.b=false; });

  selBtn.addEventListener('click', ()=>{ /* reserved */ beep(520,0.05); });
  staBtn.addEventListener('click', ()=>{ paused = !paused; });

  ui.pause.addEventListener('click', ()=> paused = !paused);
  ui.restart.addEventListener('click', ()=> resetGame());

  // ===== Game helpers =====
  const rnd=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  // ===== Map (tile-based) =====
  const TILE = 26; // a bit smaller for more GBA-ish density
  const MAP_W = 32;
  const MAP_H = 20;

  // tile types:
  // 0 grass, 1 fence/wall, 2 path, 3 flower, 4 sign, 5 gate (locked), 6 gate open, 7 terminal, 8 chest
  const map = Array.from({length:MAP_H}, (_,y)=>Array.from({length:MAP_W}, (_,x)=>{
    const border = (x===0||y===0||x===MAP_W-1||y===MAP_H-1);
    if(border) return 1;
    // base grass
    return 0;
  }));

  // add a path stripe
  for(let x=2; x<MAP_W-2; x++){
    map[9][x]=2;
  }
  // add some fences and shrubs blocks
  for(let y=3;y<9;y++) map[y][14]=1;
  for(let y=11;y<17;y++) map[y][18]=1;

  // make openings
  map[6][14]=2;
  map[14][18]=2;

  // decorate with flowers
  const flowers = [
    [6,6],[7,6],[6,7],
    [24,6],[25,6],
    [9,14],[10,14],[9,15],
    [22,14],[23,14],[22,15]
  ];
  for(const [x,y] of flowers) map[y][x]=3;

  // Checkpoints on the path:
  // CP1 sign, CP2 terminal, CP3 chest
  map[9][6]=4;   // sign
  map[9][16]=7;  // terminal
  map[9][26]=8;  // chest

  // gates (locked) after each checkpoint
  map[9][10]=5;  // gate1
  map[9][20]=5;  // gate2
  map[9][30]=5;  // gate3 near end (but border is wall; so put at 29)
  map[9][29]=5;

  function isSolidTile(t){
    return (t===1 || t===5); // wall or locked gate
  }

  // ===== Game state =====
  const ANSWERS = ["JUPITER","SPARK","GT"]; // from your physical riddles
  let state = {
    player:{x:4*TILE, y:8*TILE, face:'down', spd:140},
    cam:{x:0,y:0},
    unlocked:[false,false,false], // gates opened
    keysFound:[],                 // just for HUD display
    dialogQueue:[],
    canInteract:true,
    aLatch:false,
    bLatch:false,
    promptOpen:false,
    win:false
  };

  function resetGame(){
    hideWin();
    closePrompt();
    closeDialog();
    paused=false;
    state = {
      player:{x:4*TILE, y:8*TILE, face:'down', spd:140},
      cam:{x:0,y:0},
      unlocked:[false,false,false],
      keysFound:[],
      dialogQueue:[],
      canInteract:true,
      aLatch:false,
      bLatch:false,
      promptOpen:false,
      win:false
    };
    updateHUD();
  }

  function updateHUD(){
    const done = state.unlocked.filter(Boolean).length;
    ui.progress.textContent = `Puertas: ${done}/3`;
    ui.inv.textContent = `Keys: ${state.keysFound.length ? state.keysFound.join(' ¬∑ ') : '‚Äî'}`;
  }

  // ===== Dialog =====
  function openDialog(name, lines){
    state.dialogQueue = lines.slice();
    dName.textContent = name;
    dHint.textContent = "Pulsa A pa‚Äô continuar ¬∑ B pa‚Äô cerrar";
    dialog.style.display='block';
    nextDialogLine();
  }
  function nextDialogLine(){
    const line = state.dialogQueue.shift();
    if(!line){
      closeDialog();
      return;
    }
    dText.textContent = line;
    beep(660,0.03,'square',0.03);
  }
  function closeDialog(){
    dialog.style.display='none';
    state.canInteract = true;
    state.dialogQueue = [];
  }

  // ===== Prompt modal (code entry) =====
  let currentCheckpoint = -1;

  function openPrompt(cpIndex){
    currentCheckpoint = cpIndex;
    state.promptOpen = true;
    prompt.style.display='flex';
    pInput.value='';
    pMsg.style.display='none';
    pTitle.textContent = `Checkpoint ${cpIndex+1}`;
    pBody.textContent = `Escribe la clave del papel #${cpIndex+1}.`;
    setTimeout(()=>pInput.focus(), 50);
  }
  function closePrompt(){
    prompt.style.display='none';
    state.promptOpen = false;
    currentCheckpoint = -1;
  }
  function setPromptMsg(text, ok){
    pMsg.style.display='block';
    pMsg.textContent = text;
    pMsg.className = `msg ${ok?'ok':'bad'}`;
  }

  pCancel.addEventListener('click', closePrompt);
  pOk.addEventListener('click', validatePrompt);
  pInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter') validatePrompt();
    if(e.key === 'Escape') closePrompt();
  });

  function validatePrompt(){
    if(currentCheckpoint < 0) return;
    const got = (pInput.value||'').trim().toUpperCase();
    const expected = ANSWERS[currentCheckpoint];

    if(got === expected){
      beep(880,0.08);
      setPromptMsg("‚úÖ Correcto. Puerta desbloqueada.", true);
      unlockGate(currentCheckpoint);
      // show nice dialog and close
      setTimeout(()=>{
        closePrompt();
        openDialog("Sistema", [
          `Clave aceptada: ${expected}`,
          "Sigue avanzando por el camino üòâ"
        ]);
      }, 450);
    } else {
      beep(220,0.08);
      setPromptMsg("‚ùå Nope. Revisa la adivinanza del papel.", false);
    }
  }

  function unlockGate(i){
    if(state.unlocked[i]) return;
    state.unlocked[i] = true;
    state.keysFound.push(ANSWERS[i]);
    updateHUD();

    // Replace gate tile with open gate (walkable)
    const gateX = (i===0?10 : i===1?20 : 29);
    map[9][gateX] = 6;

    // confetti mini burst
    burstConfetti(60);
  }

  // ===== Win Screen =====
  function showWin(){
    paused = true;
    state.win = true;
    winModal.style.display = 'none';
    winOverlay.style.display = 'flex';
    burstConfetti(180);
    beep(980,0.10);
  }
  function hideWin(){
    winOverlay.style.display='none';
    winModal.style.display='none';
  }

  trophyBtn.addEventListener('click', ()=>{
    winModal.style.display = (winModal.style.display === 'block') ? 'none' : 'block';
    beep(740,0.06);
  });

  function yesAction(){
    burstConfetti(220);
    beep(880,0.10);
    alert("üíú Girlfriend_mode = true ‚úÖ");
  }
  winYes1.addEventListener('click', yesAction);
  winYes2.addEventListener('click', yesAction);
  winClose.addEventListener('click', hideWin);

  // ===== Confetti =====
  let confetti = [];
  function piece(){
    const colors = ['#b86bff','#ff5cc8','#ffffff','#52ffa8','#ffd36a'];
    return {
      x:rnd(0, window.innerWidth),
      y:-20-rnd(0,120),
      vx:rnd(-120,120),
      vy:rnd(140,320),
      r:rnd(6,12),
      rot:rnd(0,Math.PI),
      vr:rnd(-2,2),
      c:colors[Math.floor(rnd(0,colors.length))],
      life:rnd(1.2, 2.4)
    };
  }
  function burstConfetti(n=160){
    confetti = confetti.concat(Array.from({length:n}, piece));
  }
  function drawConfetti(){
    if(confetti.length===0) { cctx.clearRect(0,0,window.innerWidth,window.innerHeight); return; }
    cctx.clearRect(0,0,window.innerWidth,window.innerHeight);
    const dt = 1/60;
    confetti.forEach(p=>{
      p.life -= dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vy += 120*dt;
      p.rot += p.vr*dt;
      cctx.save();
      cctx.translate(p.x,p.y);
      cctx.rotate(p.rot);
      cctx.fillStyle = p.c;
      cctx.fillRect(-p.r/2, -p.r/2, p.r, p.r*0.6);
      cctx.restore();
    });
    confetti = confetti.filter(p=>p.life>0 && p.y < window.innerHeight+40);
  }

  // ===== Movement =====
  function getMoveVec(){
    let x=0,y=0;
    if(keys.left) x-=1;
    if(keys.right) x+=1;
    if(keys.up) y-=1;
    if(keys.down) y+=1;

    // map dpad vector to digital-ish movement
    x += dvec.x;
    y += dvec.y;

    const dz = 0.18;
    const l = Math.hypot(x,y);
    if(l < dz) return {x:0,y:0};
    return {x:x/l, y:y/l};
  }

  function movePlayer(dt){
    const p = state.player;
    const mv = getMoveVec();
    const spd = p.spd;

    if(mv.x===0 && mv.y===0) return;

    if(Math.abs(mv.x) > Math.abs(mv.y)) p.face = (mv.x>0?'right':'left');
    else p.face = (mv.y>0?'down':'up');

    const r = 9;

    function collides(px,py){
      const corners = [
        {x:px-r,y:py-r},{x:px+r,y:py-r},{x:px-r,y:py+r},{x:px+r,y:py+r}
      ];
      return corners.some(c=>{
        const tx = Math.floor(c.x / TILE);
        const ty = Math.floor(c.y / TILE);
        const t = (map[ty] && map[ty][tx] !== undefined) ? map[ty][tx] : 1;
        return isSolidTile(t);
      });
    }

    let nx = p.x + mv.x*spd*dt;
    let ny = p.y + mv.y*spd*dt;

    if(!collides(nx, p.y)) p.x = nx;
    if(!collides(p.x, ny)) p.y = ny;

    // clamp inside map
    p.x = clamp(p.x, TILE*1.2, TILE*(MAP_W-1.2));
    p.y = clamp(p.y, TILE*1.2, TILE*(MAP_H-1.2));
  }

  function updateCamera(){
    const p = state.player;
    const targetX = p.x - window.innerWidth/2;
    const targetY = p.y - window.innerHeight/2;
    const maxX = MAP_W*TILE - window.innerWidth;
    const maxY = MAP_H*TILE - window.innerHeight;
    state.cam.x = clamp(targetX, 0, Math.max(0,maxX));
    state.cam.y = clamp(targetY, 0, Math.max(0,maxY));
  }

  // ===== Interactions =====
  function tileAtWorld(x,y){
    const tx = Math.floor(x / TILE);
    const ty = Math.floor(y / TILE);
    if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return {t:1, tx, ty};
    return {t: map[ty][tx], tx, ty};
  }

  function frontTile(){
    const p = state.player;
    let fx = 0, fy = 0;
    if(p.face==='up') fy = -1;
    if(p.face==='down') fy = 1;
    if(p.face==='left') fx = -1;
    if(p.face==='right') fx = 1;
    const x = p.x + fx*TILE*0.85;
    const y = p.y + fy*TILE*0.85;
    return tileAtWorld(x,y);
  }

  function interact(){
    if(!state.canInteract) return;
    if(state.promptOpen) return;

    if(dialog.style.display==='block'){
      nextDialogLine();
      return;
    }

    const ft = frontTile();
    const {t} = ft;

    // Checkpoints
    if(t === 4){ // sign checkpoint 1
      openDialog("Letrero", [
        "Checkpoint 1.",
        "Tienes un papel con una adivinanza.",
        "Cuando la resuelvas, entra la clave aqu√≠."
      ]);
      setTimeout(()=>openPrompt(0), 150);
      return;
    }
    if(t === 7){ // terminal checkpoint 2
      openDialog("Terminal", [
        "Checkpoint 2.",
        "Introduce la clave del papel #2."
      ]);
      setTimeout(()=>openPrompt(1), 150);
      return;
    }
    if(t === 8){ // chest checkpoint 3
      openDialog("Cofre", [
        "Checkpoint 3.",
        "√öltima clave‚Ä¶ papel #3."
      ]);
      setTimeout(()=>openPrompt(2), 150);
      return;
    }

    // If standing at end after 3 unlocked, win
    if(state.unlocked.every(Boolean)){
      const p = state.player;
      // near the end gate area
      if(dist(p.x,p.y, 30*TILE, 9*TILE) < 60){
        showWin();
        return;
      }
    }

    // default hint
    openDialog("Sistema", [
      "Nada por aqu√≠.",
      "Sigue por el camino y busca los checkpoints."
    ]);
  }

  // ===== Main loop =====
  function tickInputLatches(){
    // A latch
    if(keys.a && !state.aLatch){
      state.aLatch = true;
      interact();
    }
    if(!keys.a) state.aLatch = false;

    // B latch closes dialog/prompt
    if(keys.b && !state.bLatch){
      state.bLatch = true;
      if(state.promptOpen) closePrompt();
      else if(dialog.style.display==='block') closeDialog();
    }
    if(!keys.b) state.bLatch = false;
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    if(!paused){
      tickInputLatches();
      if(!state.promptOpen && dialog.style.display!=='block' && !state.win){
        movePlayer(dt);
        updateCamera();
      }
    }

    render(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== Render =====
  function drawTile(sx,sy,t){
    // Basic tiles with pixel-ish look
    if(t===0){ // grass
      ctx.fillStyle = '#5fbf6b';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = 'rgba(0,0,0,.08)';
      ctx.fillRect(sx,sy,TILE,TILE);
      // sprinkles
      ctx.fillStyle = 'rgba(255,255,255,.10)';
      ctx.fillRect(sx+4,sy+6,2,2);
      ctx.fillRect(sx+16,sy+14,2,2);
    }
    if(t===2){ // path
      ctx.fillStyle = '#e8d38a';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = 'rgba(0,0,0,.06)';
      ctx.fillRect(sx,sy,TILE,TILE);
    }
    if(t===1){ // fence/wall
      ctx.fillStyle = '#7b8a96';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = 'rgba(255,255,255,.16)';
      ctx.fillRect(sx+2,sy+2,TILE-4,4);
      ctx.fillStyle = 'rgba(0,0,0,.18)';
      ctx.fillRect(sx+2,sy+TILE-6,TILE-4,4);
    }
    if(t===3){ // flower
      ctx.fillStyle = '#5fbf6b';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = '#ff5cc8';
      ctx.fillRect(sx+10,sy+10,6,6);
      ctx.fillStyle = '#ffd36a';
      ctx.fillRect(sx+12,sy+12,2,2);
    }
    if(t===4){ // sign
      ctx.fillStyle = '#e8d38a';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = '#8a5a2b';
      ctx.fillRect(sx+8,sy+6,10,12);
      ctx.fillStyle = '#fff';
      ctx.fillRect(sx+9,sy+8,8,3);
      ctx.fillStyle = '#ff5cc8';
      ctx.fillRect(sx+9,sy+12,6,2);
    }
    if(t===7){ // terminal
      ctx.fillStyle = '#e8d38a';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = '#3a2a55';
      ctx.fillRect(sx+7,sy+6,12,14);
      ctx.fillStyle = '#b86bff';
      ctx.fillRect(sx+9,sy+9,8,4);
      ctx.fillStyle = '#52ffa8';
      ctx.fillRect(sx+9,sy+15,4,2);
    }
    if(t===8){ // chest
      ctx.fillStyle = '#e8d38a';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = '#7b2a2a';
      ctx.fillRect(sx+7,sy+10,12,10);
      ctx.fillStyle = '#ffd36a';
      ctx.fillRect(sx+7,sy+13,12,2);
      ctx.fillStyle = '#fff';
      ctx.fillRect(sx+12,sy+13,2,4);
    }
    if(t===5){ // gate locked
      ctx.fillStyle = '#e8d38a';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = '#2b2b2b';
      ctx.fillRect(sx+10,sy+4,6,18);
      ctx.fillStyle = '#ff5a78';
      ctx.fillRect(sx+9,sy+10,8,5);
      ctx.fillStyle = '#fff';
      ctx.fillRect(sx+11,sy+12,4,1);
    }
    if(t===6){ // gate open
      ctx.fillStyle = '#e8d38a';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = 'rgba(0,0,0,.06)';
      ctx.fillRect(sx,sy,TILE,TILE);
      ctx.fillStyle = '#52ffa8';
      ctx.fillRect(sx+10,sy+4,6,18);
      ctx.fillStyle = '#fff';
      ctx.fillRect(sx+11,sy+12,4,1);
    }
  }

  function drawMap(){
    const cam = state.cam;
    const startX = Math.floor(cam.x / TILE);
    const startY = Math.floor(cam.y / TILE);
    const endX = Math.ceil((cam.x + window.innerWidth) / TILE);
    const endY = Math.ceil((cam.y + window.innerHeight) / TILE);

    for(let y=startY; y<endY; y++){
      for(let x=startX; x<endX; x++){
        if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue;
        const t = map[y][x];
        const sx = x*TILE - cam.x;
        const sy = y*TILE - cam.y;
        drawTile(sx,sy,t);
      }
    }

    // subtle vignette
    const grd = ctx.createRadialGradient(window.innerWidth/2, window.innerHeight/2, 120, window.innerWidth/2, window.innerHeight/2, Math.max(window.innerWidth,window.innerHeight));
    grd.addColorStop(0,'rgba(0,0,0,0)');
    grd.addColorStop(1,'rgba(0,0,0,.25)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
  }

  function drawPlayer(){
    const p = state.player;
    const cam = state.cam;
    const sx = p.x - cam.x;
    const sy = p.y - cam.y;

    // shadow
    ctx.fillStyle='rgba(0,0,0,.22)';
    ctx.beginPath();
    ctx.ellipse(sx, sy+10, 10, 5, 0, 0, Math.PI*2);
    ctx.fill();

    // body (red cap vibe)
    ctx.fillStyle = '#d84b4b';
    ctx.fillRect(sx-8, sy-16, 16, 16);
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(sx-8, sy, 16, 14);

    // cap
    ctx.fillStyle = '#ff5a78';
    ctx.fillRect(sx-9, sy-22, 18, 8);
    ctx.fillStyle = '#fff';
    ctx.fillRect(sx-4, sy-20, 8, 3);

    // face dot indicates direction
    ctx.fillStyle = '#fff';
    const fx = p.face==='right'? 6 : p.face==='left'? -6 : 0;
    const fy = p.face==='down'? 4 : p.face==='up'? -4 : 0;
    ctx.fillRect(sx+fx-1, sy-6+fy-1, 2, 2);
  }

  function render(dt){
    ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

    // sky-ish overlay behind map (like emulator capture)
    ctx.fillStyle = 'rgba(121,200,255,.10)';
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

    drawMap();
    drawPlayer();

    if(paused && !state.win){
      ctx.globalAlpha=0.70;
      ctx.fillStyle='rgba(0,0,0,.45)';
      ctx.fillRect(0,0,window.innerWidth, window.innerHeight);
      ctx.globalAlpha=1;
      ctx.fillStyle='#fff';
      ctx.font='900 34px system-ui';
      ctx.textAlign='center';
      ctx.fillText('PAUSA ‚è∏', window.innerWidth/2, window.innerHeight/2);
      ctx.font='800 14px system-ui';
      ctx.fillStyle='rgba(255,255,255,.75)';
      ctx.fillText('START pa‚Äô seguir', window.innerWidth/2, window.innerHeight/2 + 28);
    }

    drawConfetti();
  }

  // ===== Hook some buttons =====
  document.getElementById('pause').addEventListener('click', ()=> paused=!paused);
  document.getElementById('restart').addEventListener('click', resetGame);
  staBtn.addEventListener('click', ()=> paused=!paused);

  // ===== Prompt close with B =====
  function closePromptOnB(){
    if(state.promptOpen) closePrompt();
  }

  // ===== Start state =====
  updateHUD();

})();
</script>
</body>
</html>

